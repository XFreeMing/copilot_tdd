
# TDD的优势及问题

## 目录

- [首页](./README.md)
- [关于TDD的常见疑问](#关于tdd的常见疑问)
- [TDD 仍是时至今日最具有【工程效能】的研发流程，没有之一？](#tdd-仍是时至今日最具有工程效能的研发流程没有之一)
- [测试驱动开发的难点在哪里？](#测试驱动开发的难点在哪里)

### 其实到这里 Copilot 的出现已经大大简化了我们的工作，我们可以通过 Copilot 来完成之前后补的自动化测试的流程，而不需要再手动编写了。

### 那么为什么还要使用 TDD 呢? 
某种意义上说 TDD 认为我们很难同时达到功能正确且结构良好，然而TDD的 red/green/refactor 循环，可以让我们在功能正确的同时，保持代码结构的良好。
大家可以对比下 cli_demo 与 reconstruction_cli 两个项目的代码，就能感受到这一点。


## 关于TDD的常见疑问

- 为什么要开发人员来写测试？这难道不是测试人员的工作吗？难道开发写了测试，测试人员就不用再测了嘛？
- 又要写测试，又要写生产代码，效率是不是太低了？只写生产代码效率应该更高吧？
- 不写测试我也能写出可以工作的软件，那么写测试能给我带来什么额外的好处呢？


## TDD 仍是时至今日最具有【工程效能】的研发流程，没有之一？


### 什么是工程效能？

包含了四个方面：

- 开发功能的效能 -> 日常研发
- 发现问题的效能 -> 测试应用(Test Application)+跑一下(Run It)

- 定位问题的效能 -> 对应 Debug 手法 
- 修复问题的效能 

从理论上来说，后面三个并不是根本的复杂性问题，但在实际中却大量存在，甚至占据一半以上的有效工作时间。因而高效地完成这些非根本性问题，就可以显著地提高效率。

其中发现错误，并准确定位错误，通过发现问题的测试和定位问题的测试可以高效实现。
而如果说发现问题的测试，还有后置或外包于他人的可能，
那么定位问题的测试，无论如何都没有办法了。

所以实际上高效能的研发过程，至少需要我们提供可工作的代码，以及一组可用于定位问题的测试。


## 测试驱动开发的难点在哪里？

> 学习测试驱动开发是困难的，很多信服于测试驱动开发理念而自发实践的人也会被各种问题困扰：

- 测试从哪里来？
- 为什么我写了很多测试，功能却没有进展？
- 写什么样的测试既能驱动功能进展，又不会在重构中被破坏？
- 社区里很多人都非常推崇单元测试，但我就是要测一段 SQL，单元测试怎么测？

测试驱动开发从来都不是一种即插即用的技能，
它是一种工作习惯和思维方式(这里我个人在践行TDD时 是相当艰难的一个过程， 时至今日依然没能完全转换成功)
背后还对深层的胜任力（Competency）——分析性思考有极高的要求。
某种程度上讲，测试驱动开发有点像物理，定理写出来很简单，但需要我们在不同的场景下练习，才能应用得得心应手。


