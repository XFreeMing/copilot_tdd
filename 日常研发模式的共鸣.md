
# 日常研发模式的共鸣

## 目录
- [首页](./README.md)
- [隐式程序员测试（Implicit Developer Testing）](#隐式程序员测试implicit-developer-testing)
- [Copilot+常见的日常研发模式](#Copilot+常见的日常研发模式)


## 隐式程序员测试（Implicit Developer Testing）

直觉和经验告诉我们，在所谓的【日常软件开发模式】中，貌似测试只是最后的验收步骤，程序员很少直接参与。
但事实却不是这样，就算是所谓的【日常软件开发模式】，也蕴含着非常多“程序员测试”的步骤。

只不过这些“程序员测试”并不表现为自动化测试，而是由

- **测试应用(Test Application)**
- **跑一下(Run It)**
- **调试(Debug)** 

等隐含手段体现的。


## Copilot+常见的日常研发模式:

1. 假设我们需要将某个对象存储到数据库中，以 Java 中的 JPA（Jakarta Persistence API）为例，
那么我们大概可以构造出这样的“测试应用” 详见： com.baiying.x.tdd.normal.test_app
这个测试应用符合我们对于验证测试的一切认知：有需要被测试的行为，有明确的执行结果，以及针对结果的验证。


2. 同样，“跑一下”也不是某个技巧的正式名字。从严谨的角度出发，“跑一下”甚至不能算是它真正的名字。它真正的名字应该叫“在我本地的测试环境中跑一下”。
同样，所有人也都熟知这一技巧，就真的是“在我本地的测试环境中跑一下”。因为当代应用通常都在受控环境中运行（Managed Environment），所以当验证某个功能时，需要连通其所在的受控环境一起执行。
让我们再看一个具体的例子。假设我们需要实现 REST API，以 Java 中的 JAX-RS（Jakarta Restful WebService）为例，那么我们大概会这样来跑一下：详见： test>com.baiying.x.tdd.normal.run_it


3. 我想你已经发现了模式，你肯定要猜测“调试”也是一种验证测试，但并不是这样！“测试应用”和“跑一下”这两种技巧更多地关注在发现问题上，可以看作是“验证测试”。
而“调试”通常发生在已经明显知道有错误的代码中，是一个定位错误的过程。让我们来看个例子：详见： test>com.baiying.x.tdd.normal.debug


### 其实到这里 Copilot 的出现已经大大简化了我们的工作，我们可以通过 Copilot 来完成之前后补的自动化测试的流程，而不需要再手动编写了。

### 那么为什么还要使用 TDD 呢? 
1. 某种意义上说 TDD 认为我们很难同时达到功能正确且结构良好 TDD 的 hong/green/refactor 循环，可以让我们在功能正确的同时，保持代码结构的良好。
2. TDD 通过测试驱动开发，可以让我们在编写代码的时候，更加专注于功能的实现，而不是在调试的时候，才发现问题。


