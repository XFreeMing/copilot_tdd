
# Copilot+TDD


## TDD基本原则

TDD的创始人：Kent Beck 在他的传世大作 Tese-Driven Development: By Example 中提出了TDD的基本原则

1. 当且仅当存在失败的自动化测试时，才编写生产代码
2. 消除坏味道

## TDD的工作步骤

1. 红： 编写一个失败的小测试，甚至可以时无法编译的测试
2. 绿：让这个测试快速通过，甚至不惜犯下任何罪恶
3. 重构：消除上一步中产生的所有坏味道

然而红/绿/重构循环仅仅关注单个测试这个层面，它没有回答测试从何而来，
于是很多尝试采用TDD的人都卡在了第0步：我该写哪些测试？
于是作者徐浩总结了任务分解法，将任务列表作为TDD的核心要素。

## 任务分解法

1. 大致构思软件被使用的方式，把握对外接口的方向；
2. 大致构思功能的实现方式，划分所需的组件（Component）以及组件间的关系（所谓的架构）。
3. 根据需求功能描述拆分功能点，功能点要考虑 正确路径 （Happy Path）和 边界条件 (Sad Path)
4. 依照组件以及组件间的关系，将功能拆分到对应组件
5. 针对拆分的结果编写测试， 进入 红/绿/重构循环





## TDD演示

接下来我将演示如何通过 TDD 的方式完成一段完整的功能，让大家对 TDD 的做法有个感性的认识，并且也可以看到Copilot在TDD中的应用。

1. 任务分解与整体流程
2. 识别坏味道与代码重构
3. 按测试策略重组测试
4. 状态验证

接下来，我会通过 TDD 来实现命令行参数解析的功能。这个练习源自 Robert  的 *Clean Code* 第十四章的一个例子。需求描述如下：

> 我们中的大多数人都不得不时不时地解析一下命令行参数。如果我们没有一个方便的工具，那么我们就简单地处理一下传入 main 函数的字符串数组。有很多开源工具可以完成这个任务，但它们可能并不能完全满足我们的要求。所以我们再写一个吧。

> 传递给程序的参数由标志和值组成。标志应该是一个字符，前面有一个减号。每个标志都应该有零个或多个与之相关的值。例如：

```shell
-l -p 8080 -d /usr/logs
```
> - “l”（日志）没有相关的值，它是一个布尔标志，如果存在则为 true，不存在则为 false。
> - “p”（端口）有一个整数值，
> - “d”（目录）有一个字符串值。标志后面如果存在多个值，则该标志表示一个列表：
> 









https://time.geekbang.org/column/article/502056

![alt text](image.png)














参考课程：https://time.geekbang.org/column/article/494207
